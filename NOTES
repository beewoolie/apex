================
APEX Boot Loader
     NOTES
================

TODO:

  o Let's add a target to build all
    o We should be able to build all of the default configurations
    o Then, output of each binary is proof that build works
    o This needs a way to change the compiler without editing the makefile. 

  o Let's add a driver alias function.
    o once we get into the thick of driver-land, we may have some
      cumbersome driver specs
      o ls fat.mmc.spi:/
      o copy tftp.emac-1:vmlinuz mem:0x2000
    o The cascade of drivers will be necessary for the sake of
      interoperation, but it might make things difficult for the user.
    o So, alias fat.mmc.spi mc
    o Then  ls mc:/  will do the right thing.
    o Cake   
    o Also, we may need to pass parameters to a driver.
    o ls fat(1).mmc.spi:/ might be a reference to the first partition
    o ls mc(1):/ would be equivalent
    o I can imagine that some aliases might be generated at runtime as
      defaults.  I don't have specifics right now.
    o This also suggests that region spec's will have a qualifier
      about the compatible formats.  Filespecs and memory region specs
      may not be compatible.  Or not. :-)

  o The MASK_AND_SET macro I'm using used to be commented out.  Well,
    it was similar.  I changed it a little and put it back because the
    two step version make the ADC_PC register setup break.  Don't know
    why.  Need to make sure that all of the other code is still
    working.

  o driver info functions, especially memory
    o I think this should be done with a service hook instead of a
      driver hook so that the environment can report describe it's
      descriptor.
    o started.
    o hook removed, switched to a service entry point 
  o look for more unused symbols
  o Doc on XIP kernel?  We *can* linux run completely from flash
  o command history

  o lh7a40x
    o buffered NOR write...oh boy is this needed
    o Should be little else since there is only one memory device
    o Not much incentive to be small with 80k of SRAM
  o CONFIG_ENV_SAFE_ERASE to allow user to erase whole
    environment...there is already a configuration option for this. 

  o Exceptions vectors at the start of the loader probably don't make
    sense.  
    o If we every enable interrupts, we won't be running this loader
      from the start of addressable memory.  I suppose we could, but
      that hasn't been the way.  The kernel needs to load at
      0xc0008000 or 32K from the start, and the parameters load at
      0xc0000100 which is even worse.  Just not a good plan with
      linux.
    o Instead, we'll map some kind of RAM at 0, tell the CPU to map
      exceptions to zero, and well write vectors there.
    o This way, we can have interrupts in the loader without the MMU.
  o Simple interrupts
    o 32 entry function table
    o irq disabled if the function is empty.
    o no priorities
    o partially implemented, but non-functional 

  o Need to regularize the sdram and nor flash config parameters.  The
    arch determines some of these parameters.  Config should only
    enable.  For example, CONFIG_SDRAM_BANK0=y and the rest comes from
    the platform.  Perhaps the config should specify info on the SDRAM
    chip(s).

  o Replace # with + in regions.

Goals

  o Simple structure
  o Memory image may be directly written to flash
    o This may be challenged by structures that have defaults and are
      later modified.  If we can avoid doing this, then all will be
      well.
  o Use of tables of pointers to handle features, commands, drivers
  o Driver self-discovery when relevent
  o Small image, less than 16K for basic loader
    o This will be hard when using the kernel's printf
    o CONFIG_SMALL helps 
  o Reasonably configurable at ./configure time
  o Good command line support
  o Code sharing among targets is *not* of the highest priority
  o No assembler files
    o There is some hand assembly in the start-up, but that's probably
      unavoidable.
    o Still, no .s files 
  o No external dependencies aside from a tool chain
  o Staged execution (see below)
  o Support for over-the-wire and NAND booting--teeny tiny bootstrap
    o relocate function
    o Presently, there is only one relocate supported.  We may want to
      let it be flexible so that the loader can be common for several
      configurations.
  o Multiple targets
  o May execute from FLASH, XIP
  o Stack storage will be required
  o Automatically relocating
    o This is done in the relocate_apex() routine.  It's position
      independent up to the point that this function executes.
      Afterward, absolute symbols may be used.  Note that weak
      symbols, at the moment, cannot be used until after relocation.

  o IO descriptor (region): "device:path"
    o "nor:@0x44000000#0x20000"
    o "nand:@0#0x20000"
    o "serial:xmodem", "serial:binary"
    o "eeprom:"
    o allows drivers to handle details of transfers
      o copy "nor:@0x44000000#0x20000" to "mem:@0x20000000"
      o copy "tftp://192.168.8.1/zImage" to "mem:@0x20000000"
      o copy "http://192.168.8.1/zImage" to "nor:@0"
      o erase "nor:@0#0x200000"
    o Should support for suffixes, m,k
    o Relaxed the @ requirement.  memory driver is the default which
      means that 1m#1k specifies 1KiB from the 1MiB boundary

  o devices are self descriptive to the extent that they can be in
    terms of erase block sizes and so on

Staged Execution

  o Essential initialization, SDRAM, memory controller, IO multiplexing
  o Move loader into storage for execution, if necessary.  May involve
    transfer from secondary medium: serial, NAND flash, serial eeprom
  o Finish hardware initialization
  o Setup stack
  o Clear BSS
  o Command loop

Configuration parameters

  o Initial base address (turns out not to be necessary on ARM)
  o Execution base address
  o Base RAM address for 4K stack, data, BSS
  o Layout of SDRAM memory

Parameters

  o APEX_STACK - Linker calculated top of stack
  o APEX_VMA_START - Execution (virtual) memory address for image
  o APEX_VMA_END   - Linker calculated end of the execution memory image
  o APEX_BSS_START - Linker calculated start of BSS region
  o APEX_BSS_END - Linker calculated End of BSS region

Symbols

  o init () - driver initialization and then loader exec () 
  o reset () - initial entry point
  o exception_error () - function called for unused exceptions
  o relocate_apex () - move loader into RAM from...whereever 
  o initialize_bootstrap () - pre-relocate initialization
  o initialize_target () - completion of target (non-driver) initialization
  o setup_c () - prepare C exection environment
  o after setup_c() we can use traditional C code for the rest of
    initialization

Drivers

  o read/write, block/byte
  o erase
  o status/info
  o init/detect -> probe()
  o exit -> release()

Basic commands

  o display
  o verify
  o checksum
  o copy
  o boot (linux kernel)
  o go (arbitrary execution)
  o printenv/setenv

Sections

  o .entry - guaranteed first section.  Should contain only one symbol
  o .bootstrap - guaranteed to follow .entry.  Smallest possible
    section of code to handle bootstrap into RAM, if necessary
  o .text - rest of loader code
  o .init - initialization hooks, especially drivers
  o .env - environment hooks
  o .exit - hooks to call before leaving loader
  o .cmd - command functions
  o .bss - BSS
  o .data - initialized data

Configuration

  CONFIG_ARM - ARM target
  CONFIG_LH7952X
  CONFIG_LH79520
  CONFIG_LH79524
  CONFIG_LPD79520
  CONFIG_LPD79524
  CONFIG_LH7A40X
  CONFIG_LH7A400
  CONFIG_LH7A404
  CONFIG_LPD7A400
  CONFIG_LPD7A404
  CONFIG_CONSOLE_DEVICE - Defines which serial (or other) device is console

Kernel Build Scripts

 o The directory Makefiles may be invoked in two different situations.
   Actually, only the primary one, for the architecture, is like that.
   It may be included in the top-level Makefile in which case it is
   used to configure how the kernel will be built.  It may then be
   invoked as a Makefile used to build targets in that directory.  This
   can be confusing when it needs to define targets that must not
   override the default for the top-level Makefile.  The kernel doesn't
   need to worry about this, I believe, because it does not depend on
   the arch/$(ARCH) directory to build a target necessary for the
   vmlinux file.  Instead, it only calls arch/$(ARCH)/Makefile to build
   boot targets.

Weak Symbols

 o Using weak symbols in the entry code would make it easy to replace
   startup features with a platform specific implementation.  Trouble
   is, weak symbols cannot be called with a simple "bl" because the
   compiler and linker are not going to know where the code is and may
   not be confident that it will be nearby.  I wonder if I can hint
   that the routine must be close?
 o Libraries solve this problem as can be seen with the
   relocate_apex () function (NAND version).

Code Size

 o The printf code is really big.  We could probably use a smaller
   printf function and save some code.  It's about 4K right now.
   There is a smaller version online.  I'd like to review uClib before
   depending on code found on the net.
 o We can probably shrink all of the driver code by removing the fh
   parameter and folding the descriptor functionality into a single
   structure.  This also means that the open call can be global as can
   seek.
   o Done.

Toolchain

 o The 3.3 compiler that has worked so well for so long, seems to have
   a problem with the printf() function.  The call

     printf ("read done\r\n");

   is automatically translated as puts which should be OK, except that
   it doesn't copy the string correctly.  The final \n is truncated
   from the constant pool.  Adding -fno-builtin-printf fixes the
   problem.

Glitches

 o Every now and then, the NOR flash gets wedged.  Power cycling is
   not enough.  In this most recent case, it because corrupt and would
   not accept erase commands.  I sent a couple of commands to the
   device, switched to the other bank, and finally unlock/erase
   worked.  I think it might be wise to operate the VPEN line in the
   flash driver.
   o I think that this might be part of a problem with writing to
     flash when VPEN is enabled as we don't intend to do so.

NOR

 o Driver is kinda big and there isn't even a write function.
 o Can we aggregate some of the common driver logic, descriptors and all?
   o some of this has been done with good effect
 o Available and start address calc can be handled by a function for
   all cases...maybe.  There is a difference between blocking and
   banking.  Perhaps it would be good to limit all operations to
   blocks so that the code can be identical in all cases.

Environment and Startup

 o There is a single environment variable that contains a startup
   command.  This will be executed when the loader starts.
   o  done
 o There is a timed delay function that will wait the specified number
   of seconds (tenths) before continuing to execute the script
   command line.

     copy nor:0x400000#0x100000 0x20008000 ; \
     wait 50 Automatic boot in 5 seconds ; \
     boot

 o Pressing a key will discontinue the script execution

Spinner/Progress

 o would be nice to have a standard UI call to emit progress
   feedback.  Erasing, for example, takes quite a bit of time.
   o done
 o The performance of each driver varies.  It might be handy to have a
   stepping value for each driver when writing so that we can properly
   scale them.  Or, we could add code to insert the current byte count
   into the spinner code and let it determine when to write.

NAND Flash Drivers

  o There is a need to support the LPD method of controlling the NAND
    flash as well as the Sharp method.
  o The LPD method is implemented and tested.
  o The Sharp method should be OK as long as we don't want to use
    CompactFlash or large NOR flash.  CF would be OK as long as the
    implementation didn't require the A23 line as Logic does.
    Refer to CONFIG_NAND_LPD.
  o I am unable to erase the second flash block.  I don't know if this
    is a new problem, or if this has always been the case.  The
    datasheet gives me the impression that this is a problem with the
    chip enable.
    o This was a problem with the math 
  o relocate_apex for NAND flash 
    o This is finally working reliably.  It really won't work without
    the CPLD, but it close.
  o At this point, the relocate_nand function (should) work regardless
    of whether or not the board is running with a Logic style CPLD.
    Kurt is not coming to my way of thinking which is that there is a
    boot-up mode that mimics the Sharp method and a CPLD configurable
    mode that is faster.
  o Latest CPLD from Kurt works correctly in both modes.  We can now
    perform IO in the Sharp way and in the Logic way.  Relocator
    tested in both as is the drv-nand.  Kernel driver is likely to be
    Logic mode only for now.

Errors

  o It might be handy to have some form of debug output available.  We
    have situations where the system cannot get to the prompt, but it
    might be helpful to know why.  For example, a system is booted
    from NAND, but there is not NAND aware relocation function.
    Generally, I'm OK with little error handling since it is usually
    wasted space.

Relocation

  o The relocation code now checks to see if it is already executing
    from the target location. If so, it will return immediately.
  o The relocation code, too, will not restart the loader, but must
    always continue with a proper return.  If we only have the NAND
    relocator, then we have no way of moving the loader in SDRAM if it
    has been put in SRAM or SDRAM at some random location.  This may
    be a shortcoming.

Performance

  o The load time from flash to SDRAM is partially goverened by the
    EMC controller setup.  It may be desirable to make sure that the
    EMC is optimally configured before relocate_apex.

UART Initialization

  o It is OK to defer critical UART initializations to the serial
    driver.
  o However, the kernel usually expects that the UART is available
    during startup and it may be possible to disable the serial driver
    in APEX in order to save space.

Interrupt Handling

  o It should be possible to catch interrupts in the boot loader. 
  o Most of the code is implemented (for one platform) and enabled
    with CONFIG_INTERRUPTS.
  o The key piece missing is that the interrupt vectors must either be
    written to flash, or the MMU must be enabled so that the page with
    the vectors is available at address zero.
  o Untrue, we can use the RCPC to put SDRAM (or SRAM) at 0x00000000. 

Console

  o Document how to setup console on the LCD device as well as the
    serial:

      console=tty0 console=ttyAM0,115200

