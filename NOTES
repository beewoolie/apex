================
APEX Boot Loader
     NOTES
================

TODO:

  o Looks like the ADC test driver may interfere with the kernel
    booting properly.  First I've seen of it.  It's OK, though, since
    we don't need it.

  o Might be good to have a paranoid setting that lets us require
    confirmation before clobbering flash or eeproms or whatever.  This
    could be a list of important regions.  The region list could be
    bothersome since there is aliasing unless it is specific to the
    driver that can clobber it.

  o Buried region strings must be revealed.  The emac driver has one
    for the MAC address EEPROM.  The fatfs driver has one for the
    underlying block device.  The latter may be best revealed with an
    environment variable...or not.  Don't know about the emac one.
    There is an intention to let the user specic the fatfs support
    driver with the region string.  fatfs:cf: or something.

  o Need to rectify the vpen_enable code in the flash drivers.  It
    ought to be something defined in the hardware file s.t. it is not
    compiled unless needed.  IIRC, it was smaller to put the vpen code
    into functions that to put it inline.  However, it is easier to
    code if it can be inlined.  Hmm.

  o Would be nice if ^C could break into long-running functions.
    Could be dangerous, though, e.g. writing to flash.  More thought
    needed.

  o I am suspicious that the nor-cfi erase code isn't quite right.
    When asked to erase nor:0+120k, I think it erased the block at
    nor:120k.

  o Checksum function doesn't appear to work over fat read files.  It
    needs to clever about summing in the case that the descriptor
    itself knows the length.

  o Wonder if I need, before performing reset, do a shutdown s.t. I
    can put the nor flash in the right state.  This might be why reset
    sometimes fails.

  o Add a -v option to copy to make sure the copy is successful.

  o Implement DEBUG_LL for lpd79524 so we can see what's happening to
    the register allocation in relocate_apex.

  o There ought to be a target to release that increments the version
    number, makes an SVN copy, and pushed the code to the ftp server.

  o I'd like to mode the CROSS_COMPILER assignment to the
    configuration file *and* allow the user to override it.  The ?=
    operator isn't working for some reason.  I'll leave it for now.

  o Need to add an info function.  I can be used to get info from a
    driver or to look at a directory listing from FAT.  This idea
    isn't quite complete.  It would be good to combine the driver info
    stuff with this function in a way that the command 'describes' a
    descriptor.  Thus, a descriptor for an exact file shows the file
    info.  A descriptor for a directory lists the directory.  A
    descriptor for a driver describes that driver.

  o The default length for descriptors needs to be thought out.  If we
    set the default length to the greatest length available, then we
    run into trouble with dump.  We could communicate something about
    the use to the open call such that the driver knows if it needs to
    set a default length.  Or we could let the user do something
    interesting such as giving a @+. to indicate that the maximum
    length should be used.  The problem is one of use.  In files, the
    default length is usually going to be the whole file.  In memory
    regions, the default length is OK where it is.  I think it is best
    to add a more mode to dump and call it good.  Also, we might need
    a way to cancel some commands that run awry because of the
    (possibly) excessive elength.

  o It would be good to add a checksum function that can be compared
    to a command line tool.  MD5 or SHA1.  We want something that can
    be small, though.  Grrr.  We could also write a utility that can
    do the same checksum on the UNIX command line.
    o Yipee!  The cksfv program does the right thing.
    o Add to the documentation that the cksfv program can be used to
    compare checksums.

  o Need a function like ls or info that can list the contents of a
    directory or give data on a device.  Perhaps we can overload the
    info function to allow a complete descriptor instead of just a
    driver.  Not a bad idea.  This, then because a function of a
    driver to allow a describe, info, catalog, or whatever on a
    descriptor.

  o It would be nice if the fat/cf interface could be smart about
    detecting device changes.  Trouble is, CIS info doesn't appear to
    be enough.  It may be possible to use the hardware to detect a
    device change and propagate that upward.
    o This would probably require an extra hook in the driver.

  o APEX prints an error when the startup command doesn't have a trailing ';'

  o We can write an erase function that can cope with erasing a
    portion of a flash block.  Actually, not really too hard.
    o This could be used to erase the environment when it follows the
      loader in the same flash block.
    o This might be dangerous and, therefore, require some
      precautionary words for the user.

  o Dump command needs a MORE mode.  Or, we need to limit the extent
    of the dump. 

  o Let's add a driver alias function.
    o once we get into the thick of driver-land, we may have some
      cumbersome driver specs
      o ls fat.mmc.spi:/
      o copy tftp.emac-1:vmlinuz mem:0x2000
    o The cascade of drivers will be necessary for the sake of
      interoperation, but it might make things difficult for the user.
    o So, alias fat.mmc.spi mc
    o Then  ls mc:/  will do the right thing.
    o Cake   
    o Also, we may need to pass parameters to a driver.
    o ls fat(1).mmc.spi:/ might be a reference to the first partition
    o ls mc(1):/ would be equivalent
    o I can imagine that some aliases might be generated at runtime as
      defaults.  I don't have specifics right now.
    o This also suggests that region spec's will have a qualifier
      about the compatible formats.  Filespecs and memory region specs
      may not be compatible.  Or not. :-)
    o This aliasing could be used to refer to regions.  
      o alias apex: is the region of memory where apex is executing
      o alias env: is the region where the environment is stored.

  o The MASK_AND_SET macro I'm using used to be commented out.  Well,
    it was similar.  I changed it a little and put it back because the
    two step version make the ADC_PC register setup break.  Don't know
    why.  Need to make sure that all of the other code is still
    working.

  o driver info functions, especially memory
    o I think this should be done with a service hook instead of a
      driver hook so that the environment can report describe it's
      descriptor.
    o started.
    o hook removed, switched to a service entry point 
  o look for more unused symbols
  o Doc on XIP kernel?  We *can* linux run completely from flash
  o command history

  o lh7a40x
    o buffered NOR write...oh boy is this needed
    o Should be little else since there is only one memory device
    o Not much incentive to be small with 80k of SRAM
  o CONFIG_ENV_SAFE_ERASE to allow user to erase whole
    environment...there is already a configuration option for this. 

  o Exception vectors at the start of the loader probably don't make
    sense.  
    o If we every enable interrupts, we won't be running this loader
      from the start of addressable memory.  I suppose we could, but
      that hasn't been the way.  The kernel needs to load at
      0xc0008000 or 32K from the start, and the parameters load at
      0xc0000100 which is even worse.  Just not a good plan with
      linux.
    o Instead, we'll map some kind of RAM at 0, tell the CPU to map
      exceptions to zero, and well write vectors there.
    o This way, we can have interrupts in the loader without the MMU.
  o Simple interrupts
    o 32 entry function table
    o irq disabled if the function is empty.
    o no priorities
    o partially implemented, but non-functional 

  o Need to regularize the sdram and nor flash config parameters.  The
    arch determines some of these parameters.  Config should only
    enable.  For example, CONFIG_SDRAM_BANK0=y and the rest comes from
    the platform.  Perhaps the config should specify info on the SDRAM
    chip(s).

Goals

  o Simple structure
  o Memory image may be directly written to flash
    o This may be challenged by structures that have defaults and are
      later modified.  If we can avoid doing this, then all will be
      well.
  o Use of tables of pointers to handle features, commands, drivers
  o Driver self-discovery when relevent
  o Small image, less than 16K for basic loader
    o This will be hard when using the kernel's printf
    o CONFIG_SMALL helps 
  o Reasonably configurable at ./configure time
  o Good command line support
  o Code sharing among targets is *not* of the highest priority
  o No assembler files
    o There is some hand assembly in the start-up, but that's probably
      unavoidable.
    o Still, no .s files 
  o No external dependencies aside from a tool chain
  o Staged execution (see below)
  o Support for over-the-wire and NAND booting--teeny tiny bootstrap
    o relocate function
    o Presently, there is only one relocate supported.  We may want to
      let it be flexible so that the loader can be common for several
      configurations.
  o Multiple targets
  o May execute from FLASH, XIP
  o Stack storage will be required
  o Automatically relocating
    o This is done in the relocate_apex() routine.  It's position
      independent up to the point that this function executes.
      Afterward, absolute symbols may be used.  Note that weak
      symbols, at the moment, cannot be used until after relocation.

  o IO descriptor (region): "device:path"
    o "nor:@0x44000000#0x20000"
    o "nand:@0#0x20000"
    o "serial:xmodem", "serial:binary"
    o "eeprom:"
    o allows drivers to handle details of transfers
      o copy "nor:@0x44000000#0x20000" to "mem:@0x20000000"
      o copy "tftp://192.168.8.1/zImage" to "mem:@0x20000000"
      o copy "http://192.168.8.1/zImage" to "nor:@0"
      o erase "nor:@0#0x200000"
    o Should support for suffixes, m,k
    o Relaxed the @ requirement.  memory driver is the default which
      means that 1m#1k specifies 1KiB from the 1MiB boundary

  o devices are self descriptive to the extent that they can be in
    terms of erase block sizes and so on

Staged Execution

  o Essential initialization, SDRAM, memory controller, IO multiplexing
  o Move loader into storage for execution, if necessary.  May involve
    transfer from secondary medium: serial, NAND flash, serial eeprom
  o Finish hardware initialization
  o Setup stack
  o Clear BSS
  o Command loop

Configuration parameters

  o Initial base address (turns out not to be necessary on ARM)
  o Execution base address
  o Base RAM address for 4K stack, data, BSS
  o Layout of SDRAM memory

Parameters

  o APEX_STACK - Linker calculated top of stack
  o APEX_VMA_START - Execution (virtual) memory address for image
  o APEX_VMA_END   - Linker calculated end of the execution memory image
  o APEX_BSS_START - Linker calculated start of BSS region
  o APEX_BSS_END - Linker calculated End of BSS region

Symbols

  o init () - driver initialization and then loader exec () 
  o reset () - initial entry point
  o exception_error () - function called for unused exceptions
  o relocate_apex () - move loader into RAM from...whereever 
  o initialize_bootstrap () - pre-relocate initialization
  o initialize_target () - completion of target (non-driver) initialization
  o setup_c () - prepare C exection environment
  o after setup_c() we can use traditional C code for the rest of
    initialization

Drivers

  o read/write, block/byte
  o erase
  o status/info
  o init/detect -> probe()
  o exit -> release()

Basic commands

  o display
  o verify
  o checksum
  o copy
  o boot (linux kernel)
  o go (arbitrary execution)
  o printenv/setenv

Sections

  o .entry - guaranteed first section.  Should contain only one symbol
  o .bootstrap - guaranteed to follow .entry.  Smallest possible
    section of code to handle bootstrap into RAM, if necessary
  o .text - rest of loader code
  o .init - initialization hooks, especially drivers
  o .env - environment hooks
  o .exit - hooks to call before leaving loader
  o .cmd - command functions
  o .bss - BSS
  o .data - initialized data

Configuration

  CONFIG_ARM - ARM target
  CONFIG_LH7952X
  CONFIG_LH79520
  CONFIG_LH79524
  CONFIG_LPD79520
  CONFIG_LPD79524
  CONFIG_LH7A40X
  CONFIG_LH7A400
  CONFIG_LH7A404
  CONFIG_LPD7A400
  CONFIG_LPD7A404
  CONFIG_CONSOLE_DEVICE - Defines which serial (or other) device is console

Kernel Build Scripts

 o The directory Makefiles may be invoked in two different situations.
   Actually, only the primary one, for the architecture, is like that.
   It may be included in the top-level Makefile in which case it is
   used to configure how the kernel will be built.  It may then be
   invoked as a Makefile used to build targets in that directory.  This
   can be confusing when it needs to define targets that must not
   override the default for the top-level Makefile.  The kernel doesn't
   need to worry about this, I believe, because it does not depend on
   the arch/$(ARCH) directory to build a target necessary for the
   vmlinux file.  Instead, it only calls arch/$(ARCH)/Makefile to build
   boot targets.

Weak Symbols

 o Using weak symbols in the entry code would make it easy to replace
   startup features with a platform specific implementation.  Trouble
   is, weak symbols cannot be called with a simple "bl" because the
   compiler and linker are not going to know where the code is and may
   not be confident that it will be nearby.  I wonder if I can hint
   that the routine must be close?
 o Libraries solve this problem as can be seen with the
   relocate_apex () function (NAND version).

Code Size

 o The printf code is really big.  We could probably use a smaller
   printf function and save some code.  It's about 4K right now.
   There is a smaller version online.  I'd like to review uClib before
   depending on code found on the net.

Toolchain

 o The 3.3 compiler that has worked so well for so long, seems to have
   a problem with the printf() function.  The call

     printf ("read done\r\n");

   is automatically translated as puts which should be OK, except that
   it doesn't copy the string correctly.  The final \n is truncated
   from the constant pool.  Adding -fno-builtin-printf fixes the
   problem.

Glitches

 o Every now and then, the NOR flash gets wedged.  Power cycling is
   not enough.  In this most recent case, it because corrupt and would
   not accept erase commands.  I sent a couple of commands to the
   device, switched to the other bank, and finally unlock/erase
   worked.  I think it might be wise to operate the VPEN line in the
   flash driver.
   o I think that this might be part of a problem with writing to
     flash when VPEN is enabled as we don't intend to do so.

NOR

 o Driver is kinda big and there isn't even a write function.
 o Can we aggregate some of the common driver logic, descriptors and all?
   o some of this has been done with good effect
 o Available and start address calc can be handled by a function for
   all cases...maybe.  There is a difference between blocking and
   banking.  Perhaps it would be good to limit all operations to
   blocks so that the code can be identical in all cases.

Environment and Startup

 o There is a single environment variable that contains a startup
   command.  This will be executed when the loader starts.
   o  done
 o There is a timed delay function that will wait the specified number
   of seconds (tenths) before continuing to execute the script
   command line.

     copy nor:0x400000#0x100000 0x20008000 ; \
     wait 50 Automatic boot in 5 seconds ; \
     boot

 o Pressing a key will discontinue the script execution

Spinner/Progress

 o would be nice to have a standard UI call to emit progress
   feedback.  Erasing, for example, takes quite a bit of time.
   o done
 o The performance of each driver varies.  It might be handy to have a
   stepping value for each driver when writing so that we can properly
   scale them.  Or, we could add code to insert the current byte count
   into the spinner code and let it determine when to write.

NAND Flash Drivers

  o There is a need to support the LPD method of controlling the NAND
    flash as well as the Sharp method.
  o The LPD method is implemented and tested.
  o The Sharp method should be OK as long as we don't want to use
    CompactFlash or large NOR flash.  CF would be OK as long as the
    implementation didn't require the A23 line as Logic does.
    Refer to CONFIG_NAND_LPD.
  o I am unable to erase the second flash block.  I don't know if this
    is a new problem, or if this has always been the case.  The
    datasheet gives me the impression that this is a problem with the
    chip enable.
    o This was a problem with the math 
  o relocate_apex for NAND flash 
    o This is finally working reliably.  It really won't work without
    the CPLD, but it close.
  o At this point, the relocate_nand function (should) work regardless
    of whether or not the board is running with a Logic style CPLD.
    Kurt is not coming to my way of thinking which is that there is a
    boot-up mode that mimics the Sharp method and a CPLD configurable
    mode that is faster.
  o Latest CPLD from Kurt works correctly in both modes.  We can now
    perform IO in the Sharp way and in the Logic way.  Relocator
    tested in both as is the drv-nand.  Kernel driver is likely to be
    Logic mode only for now.

Errors

  o It might be handy to have some form of debug output available.  We
    have situations where the system cannot get to the prompt, but it
    might be helpful to know why.  For example, a system is booted
    from NAND, but there is not NAND aware relocation function.
    Generally, I'm OK with little error handling since it is usually
    wasted space.
    o DEBUG_LL

Relocation

  o The relocation code now checks to see if it is already executing
    from the target location. If so, it will return immediately.
  o The relocation code, too, will not restart the loader, but must
    always continue with a proper return.  If we only have the NAND
    relocator, then we have no way of moving the loader in SDRAM if it
    has been put in SRAM or SDRAM at some random location.  This may
    be a shortcoming.

Performance

  o The load time from flash to SDRAM is partially goverened by the
    EMC controller setup.  It may be desirable to make sure that the
    EMC is optimally configured before relocate_apex.

UART Initialization

  o It is OK to defer critical UART initializations to the serial
    driver.
  o However, the kernel usually expects that the UART is available
    during startup and it may be possible to disable the serial driver
    in APEX in order to save space.

Interrupt Handling

  o It should be possible to catch interrupts in the boot loader. 
  o Most of the code is implemented (for one platform) and enabled
    with CONFIG_INTERRUPTS.
  o The key piece missing is that the interrupt vectors must either be
    written to flash, or the MMU must be enabled so that the page with
    the vectors is available at address zero.
  o Untrue, we can use the RCPC to put SDRAM (or SRAM) at 0x00000000. 

Console

  o Document how to setup console on the LCD device as well as the
    serial:

      console=tty0 console=ttyAM0,115200

