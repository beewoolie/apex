TODO
====

x UART
x Timer
x mx51-pins
x efikamx.c initialization yikes!
x MMU, interrupts, cache initializations
o Add AAI mode to write.  Not critical, but we'll probably appreciate
  it if we write Apex to SPI flash.  
x Test on target to working console.
x MMC, adequate for booting
o IDE
x Linking FAT and EXT2 drivers to MMC.  This ought to work as the
  underlying driver has a simple block interface
x Fix writing of APEX image to SD card as to skip the partition
  table.  Need to make a partition table with room for APEX.
o Construct a kernel image that we can use to boot.
o Initialize PMIC
o Go!

NOTES
=====

o 2011.aug.13
  o Started on PMIC.  May need to power-up before reading ID?  Really?
  o Verified the PMIC interface setup.

o 2011.aug.12
  o SD/MMC read working, no DMA and 512 block only 
  o Still, SD/MMC is working and should be adequate for booting.
  o Need to make sure that the DOS driver and such can work.
  o ubuntu boots with

    console=tty1 root=/dev/sda2 rootwait rw quiet splash

o 2011.aug.10
  o SD identify working

o 2011.aug.08
  o Thoughts on MMC driver
  o It would be clever to separate an MMC interface that meets the
    'driver' model and a hardware interface that presents a normalized
    view of the essential MMC/SD functionality.
    o Command execute.
    o Setup, clocking, IO path width

o 2011.aug.06
  o clocks derive as shown below...unsatisfactorily
  o The CCM module allows, for example, the derivation of peripheral
    clocks from any of the PLLs.  The ESDHC defaults to PLL3, but it
    could come from PLL1 or PLL2.  This should not be assumed.

o 2011.jul.18
  x spi flash driver needs to cope with small reads.  A read of 1
    bytes doesn't yield any data.  In fact, if the read is anything
    less than an even number of words the result won't be read at
    all.  I believe that the problem is that the odd sized write
    occurs in the first transaction.  It may be worthwhile special
    casing this first exchange as the read as well as the write are
    likely to be misaligned.
  o Preparing erase and program logic.
  o Write working though it is not using the AAI mode.
  o Erase working well.
  o Still need AAI version of write for better performance.

o 2011.jul.17
  x Need to restrict the number of bytes in a single SPI transaction
    to the extent of the field within the SPI control register that
    defines in.
  x May want to have a secondary limit based on the size of the FIFO
    s.t. we write in one go all of the bytes that we can write to the
    transmit FIFO and let the receive FIFO hold the received bytes.
    Then we read them all at once.

o 2011.jul.16
  o Worked through a lot of IOMUX differences.  Seems to be OK except
    for some entries that we don't have documentation to explain.
  o SPI driver working.  Able to reliably read ID and data.
  o Fixed bug in dump that caused infinite dump when size wasn't a
    multiple of 16 bytes.
  o Pushed dump fix to remotes
  o Discovered that flash read to RAM isn't reliable.  Copying from
    RAM to RAM is OK.  copy flash:0+512 0x90000000 doesn't copy the
    first four bytes.  Dump is always OK.  Even checksum appears to
    work because it uses the same region_ functions that copy uses.
    The FIFO is 64 words.

o 2011.jul.14

  From uboot

    JEDEC ID: 0xbf:0x25:0x4a
    Reading SPI NOR flash 0x40000 [0x10000 bytes] -> ram 0x975f06e8

U-Boot# md 0x70010000
70010000: 00000000 00000000 00000000 00000000    ................
70010010: 00000000 00000000 00000003 00000000    ................

  Using bdi2000, the control and config registers receive
  0x00042020 and 0x00220022
  0x01f42021

  Control
  1 Channel select
  0 DRCTRL
  2 Pre-divider
  0 Post-divider
  2 Channel mode
  0 SMC
  0 XCH
  0 HW
  0 EN

  Control, later
  1f Burst length
  1 EN

  Control, later
  1 XCH

  Config
  0 HT length
  2 SCLK CTL (inactive low)
  2 DATA CTL (inactive low)
  0 SSB POL  (active low)
  0 SSB CTL  (single burst)
  2 SCLK POL (active low, idle high)
  2 SCLK PHA (phase 1 operation)



o 2011.jul.12
  o Boot mode switches

   +---+---+---+---+
   | 3 | 2 | 1 | 0 |
   +---+---+---+---+
     |   |   |   |
     |   |   |   +-- BT_SRC[0]            
     |   |   +------ BUS_WIDTH
     |   +---------- BT_MEM_TYPE[0]
     +-------------- BT_MEM_TYPE[1]

    o The normal system boot has the value 1110.  This boots to the
      SPI flash.
    o Normal boot is SPI Flash BT_MEM_TYPE 11 and 3 address
      BT_BUS_WIDTH 1.
    o SD memory card boot has the value 0000 on the most recent
      boards.  Earlier designs used the second SDHC device so on those
      boards the value is 0001.  SDHC boot has BT_MEM_TYPE 00 and
      BT_BUS_WIDTH 0.  The BT_SRC is 0 for SDHC1 and 1 for SDHC2.

/*
 * SPI Configs
 * */
#define CONFIG_FSL_SF                   1
#define CONFIG_CMD_SPI
#define CONFIG_CMD_SF
#define CONFIG_SPI_FLASH_IMX_SST
#define CONFIG_SPI_FLASH_CS             1
#define CONFIG_IMX_ECSPI
#define IMX_CSPI_VER_2_3
#define CONFIG_IMX_SPI_PMIC
#define CONFIG_IMX_SPI_PMIC_CS  0

#define MAX_SPI_BYTES           (64 * 4)




o 2011.jul.06
  o GPIO implementations complete.
  o Missing some cache initialization, especially l2

o 2011.jul.02
  o B3.12 CP15 registers for VMSA implementation, p B3-64 p1337 (really), p1339

  o Questions unanswered
    o What is the encoding for cp15 c9 wrt. Level 2 cache?
    o What is the PLATFORM block?  It's used to initialize some clock
      dividers.  There is a field called ICGC to set the dividers and
      it is set to 0x725 on our Efika and 0x124 on the EVK.
    o What is cp15 c0 c1 2,  L1NEON bit set based on ARM errata?
    o Where are the AIPS[0] and AIPS[4] registers documented?
    o This is in the efikamx.c initialization after some of the GPIO
      inits are done.  What does it do? 
	/* Setup GPIO group 2 */
	writel(0x01025200, 0x73f88000);
	/* Setup GPIO group 1 */
	writel(0x00000020, 0x73f84000);


o 2011.jul.01

  o watchdog should be a peripheral.  I suppose we could be paranoid
    and want to get it enabled really early, but what is the point?
    We're going to have more obvious problems if something in the very
    early setup fails.  Putting watchdog in a peripheral/service makes
    for nice modularity.
